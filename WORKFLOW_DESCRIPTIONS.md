# Workflow Descriptions

This document provides detailed narrative descriptions of each workflow in the Quiz App system.

## Figure 4.3: Quiz Creation Workflow

The quiz creation workflow begins when a host navigates to the Create Quiz page and fills out the quiz creation form, entering a quiz title, optional description, and adding one or more questions. For each question, the host enters the question text, sets a time limit (defaulting to 30 seconds), optionally uploads a question image, and creates four answer options with text for each. The host must mark one option as the correct answer for each question, and may also upload an optional cover image for the quiz. Upon clicking the "Create Quiz" button, the system performs comprehensive client-side validation, checking that the quiz title is not empty, all questions have non-empty text, each question has a correct answer selected, and all answer options contain text. If any validation fails, an error message is displayed via a toast notification and the process terminates, requiring the user to correct the issues. Upon successful validation, all uploaded images (quiz cover image and question images) are converted to Base64 format using the FileReader API, embedding them directly in the JSON payload. The prepared quiz data is then sent via a POST request to the `/api/quiz` endpoint using Axios, with the request body containing the quiz title, description, base64-encoded images, and an array of questions with their options. The Express.js server receives the request, processes it through CORS middleware and JSON body parser, and extracts the quiz data. The server then performs a sequential database transaction, first inserting the quiz record into the `quizzes` table with the title, description, and image URL, which returns an auto-generated quiz ID. For each question in the request, the system inserts a question record into the `questions` table, linking it to the quiz via the quiz ID and storing the question text, type, time limit, order index, and optional image URL, receiving the auto-generated question ID in return. For each option within each question, the system inserts an option record into the `options` table, linking it to the question via the question ID and storing the option text, correctness flag, order index, and color identifier (red, blue, yellow, or green). Upon successful completion of all database operations, the server returns a success response containing the quiz object with its ID. The client receives this response, displays a success toast notification stating "Quiz created successfully!", and automatically navigates the user to the home page where the newly created quiz appears in the quiz list, ready to be used in live sessions.

---

## Figure 4.4: Live Quiz Session Workflow

The live quiz session workflow begins when a host selects a quiz to host and initiates a room creation by sending a POST request to the `/api/room` endpoint with the quiz ID and host ID. The server checks for an existing active room for the selected quiz, and if one exists, it reuses that room; otherwise, it generates a unique 6-character room code and creates a new room record in the database. The server then loads all quiz questions and their associated answer options from the database, querying the `questions` table filtered by quiz ID and ordering by index, followed by querying the `options` table for each question. These questions are stored in an in-memory Map structure (`roomQuestions`) keyed by room ID, enabling fast access during the quiz session without repeated database queries. The room is created in the `rooms` table with the generated room code, quiz ID, and host ID. The host client establishes a WebSocket connection to the Socket.IO server running on port 5000, and upon connection, emits a `host:join` event with the room ID, causing the host's socket to join the room channel and be tracked in the server's rooms Map. The host then waits on the quiz room page, which displays the room code for players to join. When a player enters the room code and their name, their client establishes a WebSocket connection to the server and emits a `player:join` event with the room ID and player name. The server validates the player's join request, checking that the room code is valid and the room is not full; if validation fails, an error is displayed and the process terminates. Upon successful validation, the player is stored in the `players` table with the room ID, player name, socket ID, and an initial score of zero, and the player is added to the server's in-memory players Map. The server broadcasts a `player:joined` event to all clients in the room, followed by a `players:list` event containing the updated list of all players, providing real-time updates to both the host and all participants. The host can wait for additional players to join or click the "Start Quiz" button, which emits a `quiz:start` event. When the quiz starts, the server updates the room status in the database, setting `is_active` to TRUE and recording the start timestamp, then broadcasts a `quiz:started` event to all clients in the room with the total number of questions. The quiz enters a question loop, where for each question, the server retrieves the question data from the in-memory `roomQuestions` Map and broadcasts it to all clients via a `question:show` event, which includes the question text, all answer options with their colors, time limit, and optional image. The server updates the room's current question index in the database and starts a countdown timer based on the question's time limit. Players can select and submit answers during this time, and the server waits for answer submissions. When a player submits an answer, the server processes it by validating the answer correctness, calculating points based on response time (using the formula: points = max(1000 - timeTaken * 10, 100)), updating the player's score in both the database and memory, storing the answer record in the `answers` table, and broadcasting a `leaderboard:update` event to all clients with the updated player rankings sorted by score. If the time limit expires before all answers are received, the server automatically advances to show the correct answer, emitting an `answer:show` event to all clients that includes the correct option ID and answer distribution statistics. After displaying the answer and statistics for 3 seconds, the system checks if more questions remain; if yes, it moves to the next question and repeats the question loop; if no, it ends the quiz session. When the quiz ends, the server updates the room status to inactive, queries the database for the final leaderboard of all players sorted by score, and broadcasts a `quiz:ended` event to all clients with the final leaderboard data. All clients then display the final results showing the complete leaderboard with winners highlighted, and WebSocket connections are gracefully disconnected, completing the live quiz session.

---

## Figure 4.5: Answer Processing and Leaderboard Workflow

The answer processing and leaderboard workflow begins when a player selects an answer option and clicks submit, triggering the client to emit an `answer:submit` event via WebSocket with the room ID, question ID, selected option ID, and the time taken to answer in milliseconds. The server receives this event and performs validation checks, first verifying that the player exists in the in-memory players Map by checking their socket ID; if the player is not found, the process terminates silently. If the player is valid, the server then validates that the question ID exists in the room's questions and that the option ID exists for that specific question; if either validation fails, the process terminates. Upon successful validation, the server retrieves the selected option from the question's options array and checks its `is_correct` property to determine if the answer is correct. The server immediately updates the answer statistics in the in-memory `roomAnswers` Map, incrementing the count for the selected option to track answer distribution for later display. The answer is then stored in the database by inserting a record into the `answers` table with the room ID, question ID, player ID, option ID, correctness flag, and time taken, ensuring permanent storage for analytics and review purposes. If the answer is incorrect, the server immediately sends an `answer:result` event to the submitting player with the correctness status and correct option ID, and the process completes without score calculation. If the answer is correct, the server calculates the player's points using the formula: points = Math.max(1000 - (timeTaken * 10), 100), which rewards faster answers with more points, ensuring a minimum of 100 points even for answers submitted at the last second and a maximum of 1000 points for instant answers. The calculated points are then added to the player's total score by updating the `players` table in the database with an SQL UPDATE statement that increments the score field, and simultaneously updates the player's score in the in-memory players Map for fast access during the session. The server queries the database to retrieve the updated leaderboard, selecting all players in the room ordered by score in descending order, which includes the newly updated score for the answering player. This updated leaderboard is then broadcast to all clients in the room via a `leaderboard:update` event, ensuring that all participants, including the host, see the real-time ranking changes immediately. Finally, the server sends an `answer:result` event specifically to the submitting player, confirming whether their answer was correct and providing the correct option ID for reference. All clients update their user interfaces accordingly: the submitting player sees their answer result and updated position on the leaderboard, while all other players see the updated leaderboard reflecting the score change, maintaining real-time synchronization across all connected clients throughout the quiz session.

